1.使用合并 - 查找数据结构，实现估计渗漏（Percolation）问题阈值的程序。
编写一个程序，通过估算蒙特卡罗模拟渗流阈值的值。
安装Java编程环境。 按照以下一步一步的指示为您的操作系统[在计算机上安装一个Java编程环境 的Mac OS X • 视窗 • Linux的 。 按照这些指示，命令的javac-algs4和java-algs4将在这两个类路径后 stdlib.jar 和 algs4.jar 前者包含库从标准输入读取数据，写数据到标准输出 ，拉丝效果标准的平局 ，产生：随机数，计算统计和时序程序; 后者包含教科书中的所有算法。
。渗滤 鉴于由随机分布的绝缘和金属材料的复合系统：哪一部分的材料的需要是金属，使得所述复合系统是电导体？ 由于表面（或下面的油）上有水的多孔景观，在什么条件下水能够通过底部排出（或油通过表面涌出）？ 科学家已经确定被称为渗透到这种情况建模抽象的过程。
模型。 我们的模型使用网站的N -by- N坐标渗滤系统。 每个站点是打开或阻塞 。 一个 完整 的 网站 是一个开放的网站，可以通过周边（左，右，上，下）打开网站链被连接到一个开放的网站上排。 我们说的 渗滤 系统 如果在底部行中的完整的站点。 换句话说，一个系统渗滤如果我们填连接到顶部行的所有公开的网站和该进程填充在底部行一些开放部位 。 （对于绝缘/金属材料实例，开放位置对应于金属材料，使得渗透的系统具有从顶部到底部的金属路径，全部位点导电。对于多孔物质示例，开放位点对应于空白空间水可能流过，使得渗透的系统允许水填充开放位点，从顶部流到底部。）
 
该问题 在著名的科学问题，研究人员感兴趣的以下问题：如果站点独立地设定为与概率p开（并因此被阻止的概率是1 - p）的 ，那是什么系统渗滤的概率是多少？ 当p等于0，则系统不渗透; 当p等于1时，系统渗滤。 下面的图显示在网站上的空缺概率p相对于20分20个随机格（左）和100分100随机格（右）的渗滤概率。
 
 
当N是足够大的，有一个阈值p *，使得当p <P *一个随机N -by- N坐标几乎从未渗滤，和当p> P *，一个随机N -by- N坐标几乎总是渗滤液。 用于确定渗透阈值P *没有数学溶液尚未而得。 你的任务是写来估计P *的计算机程序。
。渗流数据类型 为了模拟渗滤系统，创建具有以下API数据类型过滤：
public class Percolation {
public Percolation（int N）//创建N-N网格，所有网站被阻止
public void open（int i，int j）//打开网站（第i行，第j列）
public boolean isOpen（int i，int j）// is site（row i，column j）open？
public boolean isFull（int i，int j）// is site（row i，column j）full？
public boolean percolates（）//系统渗出？
public static void main（String [] args）//测试客户端，可选
}}
按照惯例，行和列的索引i和j是1和N，其中（1,1）是左上角的网站之间的整数：一次性抛出IndexOutOfBoundsException如果任何参数开（），isOpen会（），或isFull（）超出其规定范围。 构造函数应该抛出如果N≤0的构造应该花时间成正比，N 2一个IllegalArgumentException; 所有方法应该持续恒定时间加一个常量调用union-find方法union（），find（），connected（）和count（）。
。蒙特卡罗模拟 来估算渗流阈值，考虑下面的计算实验：
•	初始化所有要阻止的网站。
•	重复以下操作，直到系统渗透：
•	选择 所有被封锁的网站中 网站（行 i，j列 ）均匀随机。
•	打开网站（行 i，j列 ）。
•	当系统渗滤时打开的位点的分数提供渗滤阈值的估计。
例如，如果根据下面的快照以20乘20的网格打开站点，则我们对渗滤阈值的估计是204/400 = 0.51，因为当第204个站点被打开时，系统渗透。
 
通过重复该计算实验Ť倍和平均的结果，我们得到的渗透阈值的更准确的估计。 设x 不会出现在我们的计算实验中公开的科技网站的部分。 样本平均值 μ 提供了渗滤阈值的估计值; 样本标准偏差 σ 测量阈的清晰度。
 
假定T是足够大（例如，至少30个），以下提供了渗滤阈值的95％置信区间：
 
要执行一系列计算实验，请使用以下API创建数据类型PercolationStats。
public class PercolationStats {
public PercolationStats（int N，int T）//在N乘N网格上执行T独立计算实验
public double mean（）// percolation threshold的样本均值
public double stddev（）// percolation threshold的样本标准偏差
public double confidenceLo（）//返回95％置信区间的下限
public double confidenceHi（）//返回95％置信区间的上界
public static void main（String [] args）//测试客户端，如下所述
}}
构造函数应抛出java.lang.IllegalArgumentException如果其中N≤0或T≤0。
此外，包括main（）方法，它有两个命令行参数 N和T，在N -by- N坐标进行牛逼独立计算实验（如上所述），并打印出均值，标准差，以及95％对于渗流阈值置信区间 。 使用标准随机从我们的标准库来产生随机数; 使用标准的统计信息，以计算样品平均值和标准偏差。
％纯Java PercolationStats 200 100
平均值= 0.5929934999999997
stddev = 0.00876990421552567
95％置信区间= 0.5912745987737567,0.5947124012262428
％纯Java PercolationStats 200 100
平均值= 0.592877
stddev = 0.009990523717073799
95％置信区间= 0.5909188573514536,0.5948351426485464
％纯Java PercolationStats 2 10000
平均值= 0.666925
stddev = 0.11776536521033558
95％置信区间= 0.6646167988418774,0.6692332011581226
％纯Java PercolationStats 2 100000
平均值= 0.6669475
stddev = 0.11775205263262094
95％置信区间= 0.666217665216461,0.66676773347835391
分析运行时间和内存使用（可选，不计分）的， 采用 快速查找算法 实现渗流数据类型 QuickFindUF.java 从algs4.jar。
•	从我们的标准库 使用 秒表数据类型 来衡量 PercolationStats 的总运行时间 。 如何加倍 ñ 影响总运行时间？ 如何加倍 牛逼 影响总运行时间？ 举一个公式（使用波浪符号）的总运行时间在电脑上（以秒为单位）为N 和 T的单一功能 。
•	从讲座采用64位内存成本模式，放弃以字节为单位（用波浪线表示）的总内存使用情况，一个 渗透 对象使用到 N -by-ñ 渗滤系统 模型 。 计数所使用的所有内存，包括用于联合查找数据结构的内存。
现在，实现采用加权快速合并算法渗流数据类型 WeightedQuickUnionUF.java 从algs4.jar。 回答上一段中的问题。
交付。 只提交Percolation.java（使用如WeightedQuickUnionUF类实现的加权快速工会算法）和PercolationStats.java。 我们将提供stdlib.jar和WeightedQuickUnionUF。 您的提交可能不会调用除java.lang，stdlib.jar和WeightedQuickUnionUF中的函数之外的任何库函数。
为了好玩， 创建自己的过滤输入文件，并在论坛分享。
此作业由Bob Sedgewick和Kevin Wayne开发。
2.你被要求写和执行下列排序算法进行了实证分析的复杂性：// 实现并做性能分析比较
（1）插入排序;
（2）合并排序（请写递归合并排序和自下而上合并）;
（3）快速排序（请写上类中的随机快速排序方法）;
（4）Dijkstra双向分区快速排序;
（5）*使用Bentley-McIlroy 3路分区快速排序。
请注意，带星号的问题是可选的。
3. 实现 的Dijkstra 单源点最短路径算法，并应用于 地图路由/ GIS 问题。
实现经典的Dijkstra的最短路径算法并优化它的地图。 这样的算法广泛用于地理信息系统（GIS），包括MapQuest和基于GPS的汽车导航系统。
地图。 对于这项任务，我们将与地图或图形的顶点是点在平面和边缘权重为欧氏距离连接中工作。 将顶点视为城市，将边缘视为连接到它们的道路。 为了在文件中表示地图，我们列出了顶点和边的数量，然后列出顶点（后面跟着它的x和y坐标），然后列出边（顶点对），最后是源和汇顶点。 例如，Input6表示以下映射：
 
Dijkstra算法，Dijkstra 算法是经典的解决最短路径问题。 它在教科书的第4.4节中描述。 基本想法不难理解。 我们维持，为图中的每一个顶点，从源到该顶点的最短已知路径的长度，和我们维持在一个优先级队列这些长度。 最初，我们将所有顶点以人工高优先级置于队列上，然后将优先级0.0分配给源。 该算法通过使最低优先级的顶点离开PQ，然后检查通过一个边缘从该顶点到达的所有顶点，以查看该边缘是否给出从源到比最短的先前已知的顶点更短的路径路径。如果是，则降低优先级以反映这个新信息。
这里是一个逐步的描述，显示了Dijkstra的算法如何在上面的例子中找到从0到5的最短路径0-1-2-5。
过程0（0.0）
低3至3841.9
低1至1897.4
过程1（1897.4）
低4至3776.2
低2至2537.7
过程2（2537.7）
低5至6274.0
方法4（3776.2）
过程3（3841.9）
过程5（6274.0）
此方法计算最短路径的长度。 为了跟踪路径，我们还为每个顶点维护其前身在从源到该顶点的最短路径上。 文件Euclidean Graph.java，Point.java，IndexPQ.java，IntIterator.java和Dijkstra.java为Dijkstra的地图算法提供了一个简单的实现，你应该使用它作为起点。 客户端程序ShortestPath.java解决单个最短路径问题，并使用龟图形绘制结果。 客户端程序Paths.java解决了许多最短路径问题，并将最短路径打印到标准输出。 客户端程序Distances.java解决了许多最短路径问题，只打印到标准输出的距离。
自己的目标。 优化Dijkstra算法，以便它可以处理成千上万最短路径的查询对于给定的地图。 一旦你阅读（和可选的预处理）地图，你的程序应该解决次线性时间最短路径问题。 一种方法是预先计算所有顶点对的最短路径; 然而，您不能承担存储所有这些信息所需的二次空间。 您的目标是减少每个最短路径计算涉及的工作量，而不使用过多的空间。 我们建议您可以选择实施一些潜在的想法。 或者你可以开发和实现你自己的想法。
理念1. 天真实现Dijkstra算法的检查图中所有的V顶点。 减少检查的顶点数目的一个明显的策略是，一旦发现到目的地的最短路径，停止搜索。 使用这种方法，您可以使每个最短路径查询的运行时间与E'log V'成比例，其中E'和V'是Dijkstra算法检查的边和顶点的数量。 然而，这需要一些注意，因为只是重新初始化所有到∞的距离将需要时间与V成正比。由于你做重复的查询，你可以通过重新初始化那些在上一个查询。
理念2. 您可以进一步通过利用问题的欧几里德几何减少搜索时间，如在部分C五本书算法对于一般图在21.5节描述，Dijkstra的通过更新D [W]放宽边缘VW到d [v]的总和加上从v到w的距离。 为地图，我们代替更新D [W]为D [V]的加总和加上从V为w的距离从ω至d 减去从v到D中的欧几里得距离的欧几里得距离。 这被称为A *算法 。 这种启发式方法会影响性能，但不会影响正确性。
3.想法 使用更快的优先级队列。 在提供的优先级队列中有一些优化空间。 你也可以考虑使用多路堆，就像Sedgewick程序20.10。
测试该 文件 usa.txt 包含87575交叉口和美国大陆121961道路。 图表非常稀疏 - 平均度为2.8。 您的主要目标应该是快速回答这个网络上的顶点对的最短路径查询。 根据两个顶点是相邻还是相距较远，您的算法可能会有不同的执行效果。 我们提供测试这两种情况的输入文件。 您可以假设所有的x和y坐标都是0到10,000之间的整数。
4 *。 霍夫曼压缩
前三个题目是必做题，第四个题目是选做题。
       
       
 
英语原文:
Percolation. Given a composite systems comprised of randomly distributed insulating and metallic materials: what fraction of the materials need to be metallic so that the composite system is an electrical conductor?
  更好的翻译建议

